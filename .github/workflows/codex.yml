# .github/workflows/codex.yml
name: Codex Auto Dev
on:
  workflow_dispatch:
    inputs:
      task_input:
        description: Task text passed to the Codex pipeline (defaults if omitted)
        required: false
  issue_comment:
    types: [created, edited]
concurrency:
  group: codex-auto-dev-${{ github.event_name }}-${{ github.event.issue.number || github.ref || 'manual' }}
  cancel-in-progress: true
permissions:
  contents: write
  issues: write
  pull-requests: write
jobs:
  codex:
    if: >-
      github.event_name == 'workflow_dispatch' ||
      (github.event_name == 'issue_comment' &&
       contains(fromJson('["OWNER","MEMBER","COLLABORATOR"]'), github.event.comment.author_association))
    runs-on: ubuntu-latest
    timeout-minutes: 60
    env:
      CODEX_NPM_PKG: "@openai/codex"
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Install jq (for flags parsing)
        run: "bash -lc $'sudo apt-get update -y\\nsudo apt-get install -y jq'"
      - name: Read Auto-Evolve flags
        id: flags
        shell: bash
        run: "bash -lc $'if [ -f .codex/flags.json ]; then echo \"found=.codex/flags.json\" >> \"$GITHUB_OUTPUT\"; echo \"json<<EOF\" >> \"$GITHUB_OUTPUT\"; cat .codex/flags.json >> \"$GITHUB_OUTPUT\"; echo \"EOF\" >> \"$GITHUB_OUTPUT\"; CANARY=$(jq -r \\'\\.canary_ratio // 0\\' .codex/flags.json); else echo \"found=(none)\" >> \"$GITHUB_OUTPUT\"; CANARY=0; fi; echo \"canary_ratio=${CANARY}\" >> \"$GITHUB_OUTPUT\"'"
      - name: Decide route (canary/main)
        id: route
        shell: bash
        env:
          CANARY: ${{ steps.flags.outputs.canary_ratio }}
        run: "bash -lc $'KEY=\"${{ github.event.issue.number || github.ref || github.run_id }}\"; H=$(printf \"%s\" \"$KEY\" | cksum | awk \\'{print $1}\\'); MOD=$(( H % 100 )); CANARY_PCT=$(python3 - <<\\'PY\\nfrom decimal import Decimal\\nimport os\\nprint(int(Decimal(os.environ.get(\\'CANARY\\',\\'0\\')) * 100))\\nPY\\n); if [ \"$MOD\" -lt \"$CANARY_PCT\" ]; then echo \"variant=canary\" >> \"$GITHUB_OUTPUT\"; else echo \"variant=main\" >> \"$GITHUB_OUTPUT\"; fi'"
      - name: Export route & role toggles to env
        shell: bash
        run: "bash -lc $'echo \"VARIANT=${{ steps.route.outputs.variant }}\" >> \"$GITHUB_ENV\"; if [ -n \"${{ steps.flags.outputs.json }}\" ]; then SR=$(printf \"%s\" \"${{ steps.flags.outputs.json }}\" | jq -r \\'\\.roles[\"Security Reviewer\"].enabled // true\\'); CQR=$(printf \"%s\" \"${{ steps.flags.outputs.json }}\" | jq -r \\'\\.roles[\"Code Quality Reviewer\"].enabled // true\\'); UXR=$(printf \"%s\" \"${{ steps.flags.outputs.json }}\" | jq -r \\'\\.roles[\"UI/UX Reviewer\"].enabled // true\\'); AIS=$(printf \"%s\" \"${{ steps.flags.outputs.json }}\" | jq -r \\'\\.roles[\"AI Safety Reviewer\"].enabled // true\\'); echo \"SKIP_SECURITY_REVIEWER=$([ \"$SR\" = true ] && echo 0 || echo 1)\" >> \"$GITHUB_ENV\"; echo \"SKIP_CODE_QUALITY_REVIEWER=$([ \"$CQR\" = true ] && echo 0 || echo 1)\" >> \"$GITHUB_ENV\"; echo \"SKIP_UI_UX_REVIEWER=$([ \"$UXR\" = true ] && echo 0 || echo 1)\" >> \"$GITHUB_ENV\"; echo \"SKIP_AI_SAFETY_REVIEWER=$([ \"$AIS\" = true ] && echo 0 || echo 1)\" >> \"$GITHUB_ENV\"; fi; if [ -n \"${{ steps.flags.outputs.json }}\" ]; then ROUTE_WEIGHTS=$(printf \"%s\" \"${{ steps.flags.outputs.json }}\" | jq -r \\'\\.route.weights // {}\\' 2>/dev/null); else ROUTE_WEIGHTS=\\'{}\\'; fi; echo \"ROUTE_WEIGHTS=$ROUTE_WEIGHTS\" >> \"$GITHUB_ENV\"'"
      - name: Announce route (log)
        if: always()
        run: "bash -lc $'echo \"Auto-Evolve route: $VARIANT\"; echo \"Security Reviewer skip flag: $SKIP_SECURITY_REVIEWER\"; echo \"Code Quality Reviewer skip flag: $SKIP_CODE_QUALITY_REVIEWER\"; echo \"UI/UX Reviewer skip flag: $SKIP_UI_UX_REVIEWER\"; echo \"AI Safety Reviewer skip flag: $SKIP_AI_SAFETY_REVIEWER\"'"
      - name: Detect trigger and compose TASK_INPUT
        id: detect
        env:
          GITHUB_EVENT_NAME: ${{ github.event_name }}
          GITHUB_EVENT_PATH: ${{ github.event_path }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: "bash -lc $'set -euo pipefail; python3 -c \"import sys, textwrap; exec(textwrap.dedent(sys.stdin.read()))\" <<\\'PY\\nimport json, os, re, sys, uuid, urllib.request\\nname = os.environ.get(\"GITHUB_EVENT_NAME\",\"\")\\npath = os.environ.get(\"GITHUB_EVENT_PATH\")\\nif not path:\\n    print(\"::error::GITHUB_EVENT_PATH is not set.\"); sys.exit(1)\\nwith open(path, encoding=\"utf-8\") as f:\\n    event = json.load(f)\\n\\ndef out(k, v):\\n    go = os.environ[\"GITHUB_OUTPUT\"]\\n    if \"\\\\n\" in v:\\n        m = f\"EOF_{uuid.uuid4().hex}\"\\n        with open(go, \"a\", encoding=\"utf-8\") as g:\\n            g.write(f\"{k}<<{m}\\\\n{v}\\\\n{m}\\\\n\")\\n    else:\\n        with open(go, \"a\", encoding=\"utf-8\") as g:\\n            g.write(f\"{k}={v}\\\\n\")\\n\\ndef coerce(x):\\n    return \"\" if x is None else str(x)\\n\\nif name == \"workflow_dispatch\":\\n    inputs = event.get(\"inputs\") or {}\\n    task = coerce(inputs.get(\"task_input\")).strip() or \"Manual trigger: Please implement the requested feature.\"\\n    out(\"run_codex\",\"true\")\\n    out(\"task_input\", task)\\nelif name == \"issue_comment\":\\n    issue = event.get(\"issue\") or {}\\n    comment = event.get(\"comment\") or {}\\n    title = coerce(issue.get(\"title\")).strip()\\n    issue_body = coerce(issue.get(\"body\")).strip()\\n    body = coerce(comment.get(\"body\")).replace(\"\\\\r\",\"\")\\n    lines = body.split(\"\\\\n\")\\n    trigger_pattern = re.compile(r\"^@?codex_agents\\\\b[:\\\\s-]*\", re.IGNORECASE)\\n    trigger_index = -1\\n    trigger_line = \"\"\\n    command_start = 0\\n    for idx, raw in enumerate(lines):\\n        stripped = raw.strip()\\n        if not stripped:\\n            continue\\n        probe = stripped\\n        while probe.startswith(\">\"):\\n            probe = probe[1:].lstrip()\\n        match = trigger_pattern.match(probe)\\n        if match:\\n            trigger_index = idx\\n            trigger_line = probe\\n            command_start = match.end()\\n            break\\n    if trigger_index < 0:\\n        out(\"run_codex\",\"false\"); sys.exit(0)\\n    head = trigger_line[command_start:].lstrip(\" \\t:-\")\\n    command = (\"\\\\n\".join([head] + lines[trigger_index+1:])).strip()\\n    if not command:\\n        command = \\\"\\\"\\\"\\\"\\n    policy = (\"You MUST follow these constraints:\\\\n1. Avoid creating unnecessary tasks and keep impact on the existing project to a minimum.\\\\n2. Complete all required fixes to deliver a finished, self-contained outcome.\")\\n    augmented_command = f\"{command}\\\\n\\\\n{policy}\".strip()\\n    def fetch_issue_comments(ev, limit=15, clip=800):\\n        repo = (ev.get(\"repository\") or {})\\n        owner = ((repo.get(\"owner\") or {}).get(\"login\")) or \"\"\\n        name  = repo.get(\"name\") or \"\"\\n        num   = issue.get(\"number\")\\n        if not (owner and name and num):\\n            return []\\n        url = f\"https://api.github.com/repos/{owner}/{name}/issues/{num}/comments?per_page=100\"\\n        headers = {\"Accept\":\"application/vnd.github+json\"}\\n        tok = os.environ.get(\"GITHUB_TOKEN\",\"\")\\n        if tok:\\n            headers[\"Authorization\"] = f\"Bearer {tok}\"\\n        req = urllib.request.Request(url, headers=headers)\\n        try:\\n            with urllib.request.urlopen(req, timeout=60) as r:\\n                arr = json.loads(r.read().decode(\"utf-8\"))\\n        except Exception as e:\\n            print(f\"::warning::Failed to fetch comments: {e}\")\\n            return []\\n        arr = arr[-limit:]\\n        out_items = []\\n        for c in arr:\\n            by = ((c.get(\"user\") or {}).get(\"login\")) or \"\"\\n            at = c.get(\"created_at\") or \"\"\\n            bd = (c.get(\"body\") or \"\").strip()\\n            if len(bd) > clip:\\n                bd = bd[:clip] + \" ...(truncated)\"\\n            out_items.append({\"by\":by, \"at\":at, \"body\":bd})\\n        return out_items\\n    conversation = fetch_issue_comments(event)\\n    payload = json.dumps({\"Issue Title\": title, \"Issue Body\": issue_body, \"Instruction\": augmented_command, \"Conversation\": conversation}, ensure_ascii=False)\\n    out(\"run_codex\",\"true\")\\n    out(\"task_input\", payload)\\n    out(\"issue_number\", coerce(issue.get(\"number\")))\\nelse:\\n    print(\"::error::Unsupported event.\"); sys.exit(1)\\nprev = (locals().get(\"payload\") or locals().get(\"task\") or \"\").replace(\"\\\\n\",\" \").replace(\"\\\\r\",\" \")\\nif prev:\\n    print(f\"TASK_INPUT preview: {prev[:200]}{'...' if len(prev)>200 else ''}\")\\nPY'"
      - name: Load previous progress for this issue
        if: ${{ steps.detect.outputs.run_codex == 'true' && github.event_name == 'issue_comment' }}
        id: progress
        run: "bash -lc $'set -euo pipefail; num=\"${{ steps.detect.outputs.issue_number }}\"; if [ -z \"${num}\" ]; then echo \"exists=false\" >> \"$GITHUB_OUTPUT\"; exit 0; fi; git fetch origin \"refs/heads/codex/issue-${num}:refs/remotes/origin/codex/issue-${num}\" || true; progress_ref=\"refs/remotes/origin/codex/issue-${num}:.codex/state/issue-${num}/progress.json\"; progress_content=\"$(git show \"${progress_ref}\" 2>/dev/null || true)\"; if [ -n \"$progress_content\" ]; then { echo \"json<<EOF\"; echo \"$progress_content\"; echo \"EOF\"; } >> \"$GITHUB_OUTPUT\"; echo \"exists=true\" >> \"$GITHUB_OUTPUT\"; else index_ref=\"refs/remotes/origin/codex/issue-${num}:.codex/state/index.json\"; index_content=\"$(git show \"${index_ref}\" 2>/dev/null || true)\"; if [ -n \"$index_content\" ]; then payload=\"$(ISSUE=\"${num}\" INDEX_CONTENT=\"$index_content\" python3 -c $'import json, os, sys\\nissue = (os.environ.get(\"ISSUE\") or \"\").strip()\\nraw = os.environ.get(\"INDEX_CONTENT\") or \"\"\\nif not issue or not raw.strip():\\n    sys.exit(0)\\ntry:\\n    data = json.loads(raw)\\nexcept Exception:\\n    sys.exit(0)\\nentry = data.get(issue) or data.get(str(issue))\\nif entry:\\n    print(json.dumps(entry, ensure_ascii=False))')\"; if [ -n \"$payload\" ]; then { echo \"json<<EOF\"; echo \"$payload\"; echo \"EOF\"; } >> \"$GITHUB_OUTPUT\"; echo \"exists=true\" >> \"$GITHUB_OUTPUT\"; else echo \"exists=false\" >> \"$GITHUB_OUTPUT\"; fi; else echo \"exists=false\" >> \"$GITHUB_OUTPUT\"; fi; fi'"
      - name: Merge previous progress into TASK_INPUT
        if: ${{ steps.detect.outputs.run_codex == 'true' }}
        id: merge
        env:
          INPUT_JSON: ${{ steps.detect.outputs.task_input }}
          PREV: ${{ steps.progress.outputs.json }}
        run: "bash -lc $'set -euo pipefail; python3 -c \"import sys, textwrap; exec(textwrap.dedent(sys.stdin.read()))\" <<\\'PY\\nimport json, os\\ntask = os.environ.get(\\'INPUT_JSON\\', \\''\\')\\nprev = os.environ.get(\\'PREV\\', \\''\\')\\ntry:\\n    data = json.loads(task)\\nexcept Exception:\\n    data = {\\'Instruction\\': task}\\nif prev:\\n    try:\\n        data[\\'PreviousProgress\\'] = json.loads(prev)\\n    except Exception:\\n        data[\\'PreviousProgressRaw\\'] = prev\\nprint(json.dumps(data, ensure_ascii=False))\\nPY\\n| { echo \"task_input<<EOF\"; cat; echo \"EOF\"; } >> \"$GITHUB_OUTPUT\"'"
      - name: Prepare working branch
        if: ${{ steps.detect.outputs.run_codex == 'true' }}
        id: prepare_branch
        env:
          BRANCH_NAME: ${{ github.event_name == 'issue_comment' && steps.detect.outputs.issue_number != '' && format('codex/issue-{0}', steps.detect.outputs.issue_number) || format('codex/run-{0}', github.run_id) }}
          BASE_BRANCH: develop
        run: "bash -lc $'set -euo pipefail; branch=\"${BRANCH_NAME}\"; base=\"${BASE_BRANCH}\"; git config user.name \"codex-workflow\"; git config user.email \"codex-workflow@users.noreply.github.com\"; git fetch origin \"${base}\"; if git ls-remote --exit-code --heads origin \"${branch}\" >/dev/null 2>&1; then git fetch origin \"${branch}:${branch}\"; git checkout \"${branch}\"; echo \"exists=true\" >> \"$GITHUB_OUTPUT\"; else git checkout -B \"${branch}\" \"origin/${base}\"; echo \"exists=false\" >> \"$GITHUB_OUTPUT\"; fi'"
      - name: Install Codex CLI
        if: ${{ steps.detect.outputs.run_codex == 'true' }}
        run: "bash -lc $'npm i -g ${CODEX_NPM_PKG:-@openai/codex}@0.39.0; codex --version'"
      - name: Restore ChatGPT auth (no API key)
        if: ${{ steps.detect.outputs.run_codex == 'true' }}
        env:
          CODEX_AUTH_JSON_B64: ${{ secrets.CODEX_AUTH_JSON_B64 }}
        run: "bash -lc $'set -euo pipefail; test -n \"${CODEX_AUTH_JSON_B64:-}\" || { echo \"::error::Missing secret CODEX_AUTH_JSON_B64\"; exit 1; }; mkdir -p \"$HOME/.codex\"; printf %s \"$CODEX_AUTH_JSON_B64\" | base64 -d > \"$HOME/.codex/auth.json\"; chmod 600 \"$HOME/.codex/auth.json\"; echo 'preferred_auth_method = \"chatgpt\"' > \"$HOME/.codex/config.toml\"; codex --version'"
      - name: Run Codex pipeline
        if: ${{ steps.detect.outputs.run_codex == 'true' }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          RUN_CODEX: ${{ steps.detect.outputs.run_codex }}
          TASK_INPUT: ${{ steps.merge.outputs.task_input }}
        run: "bash -lc $'set -euo pipefail; mkdir -p codex_output; printf %s \"$TASK_INPUT\" | ./scripts/run_codex_pipeline.sh'"
      - name: Check for clarification request
        if: ${{ steps.detect.outputs.run_codex == 'true' }}
        id: clarifications
        run: "bash -lc $'set -euo pipefail; status=\"$(python3 -c \"from pathlib import Path; import json; p=Path(''codex_output/status.json''); ns={''p'': p, ''json'': json, ''status'': ''''}; exec(\\\"if p.exists():\\\\n    try:\\\\n        status=json.loads(p.read_text(encoding=''utf-8'')).get(''status'','''') or ''''\\\\n    except Exception:\\\\n        status=''''\\\", ns); print(ns.get(''status'','''')))\"; if [ \"$status\" = \"needs_clarification\" ]; then echo \"needs_clarification=true\" >> \"$GITHUB_OUTPUT\"; if [ -f codex_output/clarifying_questions.md ]; then { echo \"questions<<EOF\"; cat codex_output/clarifying_questions.md; echo \"EOF\"; } >> \"$GITHUB_OUTPUT\"; fi; else echo \"needs_clarification=false\" >> \"$GITHUB_OUTPUT\"; fi'"
      - name: Persist progress snapshot
        if: ${{ steps.detect.outputs.run_codex == 'true' && github.event_name == 'issue_comment' }}
        id: persist
        env:
          ISSUE_NUMBER: ${{ steps.detect.outputs.issue_number }}
        run: "bash -lc $'set -euo pipefail; state_dir=\".codex/state\"; mkdir -p \"$state_dir\"; ts=\"$(date -u +%Y-%m-%dT%H:%M:%SZ)\"; export ts; python3 -c \"import sys, textwrap; exec(textwrap.dedent(sys.stdin.read()))\" <<\\'PY\\nimport os, json, pathlib\\nissue = (os.environ.get('ISSUE_NUMBER') or 'manual').strip() or 'manual'\\nrun_id = os.environ.get('GITHUB_RUN_ID', '')\\nts = os.environ.get('ts', '')\\nout = {'issue': issue, 'run_id': run_id, 'timestamp': ts}\\np = pathlib.Path('codex_output/status.json')\\nif p.exists():\\n    try:\\n        out['status'] = json.loads(p.read_text(encoding='utf-8'))\\n    except Exception:\\n        out['status_raw'] = p.read_text(encoding='utf-8')\\nq = pathlib.Path('codex_output/clarifying_questions.md')\\nif q.exists():\\n    out['clarifying_questions'] = q.read_text(encoding='utf-8')[:4000]\\nfiles = []\\nbase = pathlib.Path('codex_output')\\nif base.exists():\\n    for q in base.rglob('*'):\\n        if q.is_file():\\n            sz = q.stat().st_size\\n            item = {'path': str(q), 'size': sz}\\n            if sz <= 20000:\\n                try:\\n                    item['preview'] = q.read_text(encoding='utf-8', errors='ignore')[:4000]\\n                except Exception:\\n                    pass\\n            files.append(item)\\nout['files'] = files\\nindex_path = pathlib.Path('.codex/state/index.json')\\nif index_path.exists():\\n    try:\\n        data = json.loads(index_path.read_text(encoding='utf-8'))\\n    except Exception:\\n        data = {}\\nelse:\\n    data = {}\\ndata[issue] = out\\nindex_path.parent.mkdir(parents=True, exist_ok=True)\\nindex_path.write_text(json.dumps(data, ensure_ascii=False, indent=2), encoding='utf-8')\\nPY\\necho \"path=$state_dir/index.json\" >> \"$GITHUB_OUTPUT\"'"
      - name: Debug gates
        if: ${{ steps.detect.outputs.run_codex == 'true' }}
        run: "bash -lc $'echo \"run_codex=${{ steps.detect.outputs.run_codex }}\"; echo \"needs_clarification=${{ steps.clarifications.outputs.needs_clarification || 'n/a' }}\"; echo \"progress_saved=${{ steps.persist.outputs.path || 'n/a' }}\"'"
      - name: Comment clarifying questions to issue
        if: ${{ steps.detect.outputs.run_codex == 'true' && steps.clarifications.outputs.needs_clarification == 'true' && github.event_name == 'issue_comment' }}
        uses: actions/github-script@v7
        env:
          QUESTIONS: ${{ steps.clarifications.outputs.questions }}
        with:
          script: |
            const issue_number = Number("${{ steps.detect.outputs.issue_number }}");
            const questions = process.env.QUESTIONS || '(no questions found)';
            const body = ["Codex requires clarifications before continuing.","","### Questions",questions].join("\n");
            await github.rest.issues.createComment({ owner: context.repo.owner, repo: context.repo.repo, issue_number, body });
      - name: Stop after clarification
        if: ${{ steps.detect.outputs.run_codex == 'true' && steps.clarifications.outputs.needs_clarification == 'true' }}
        run: "bash -lc $'echo \"::notice::Waiting for user clarifications.\"; exit 0'"
      - name: Upload Codex outputs
        if: ${{ steps.detect.outputs.run_codex == 'true' }}
        uses: actions/upload-artifact@v4
        continue-on-error: true
        with:
          name: codex-agent-outputs
          path: codex_output
          retention-days: 7
      - name: Check repository diff
        if: ${{ steps.detect.outputs.run_codex == 'true' }}
        id: diff
        run: "bash -lc $'set -euo pipefail; if [ -z \"$(git status --porcelain)\" ]; then echo \"changed=false\" >> \"$GITHUB_OUTPUT\"; else echo \"changed=true\" >> \"$GITHUB_OUTPUT\"; fi'"
      - name: Summarize changes
        if: ${{ steps.detect.outputs.run_codex == 'true' && steps.diff.outputs.changed == 'true' }}
        id: summary
        run: "bash -lc $'set -euo pipefail; files=\"$(git --no-pager diff --name-only)\"; stat=\"$(git --no-pager diff --stat)\"; count=\"$(printf \"%s\\n\" \"$files\" | sed \"/^$/d\" | wc -l | tr -d \\\" \\\")\"; { echo \"change_summary<<EOF\"; echo \"Changed files ($count):\"; echo; printf \"%s\\n\" \"$files\" | sed \"s/^/- /\"; echo; echo \"Diffstat:\"; echo; printf \"%s\\n\" \"$stat\"; echo \"EOF\"; } >> \"$GITHUB_OUTPUT\"'"
      - name: Synthesize report change if needed
        if: ${{ steps.detect.outputs.run_codex == 'true' && steps.diff.outputs.changed != 'true' }}
        id: synth
        env:
          ISSUE_NUMBER: ${{ steps.detect.outputs.issue_number }}
        run: "bash -lc $'set -euo pipefail; mkdir -p .codex/reports; ISSUE_TAG=\"${ISSUE_NUMBER:-manual}\"; REPORT=\".codex/reports/${ISSUE_TAG}-${GITHUB_RUN_ID}.md\"; { echo \"# Codex Auto Dev Report\"; echo; echo \"- Run: ${GITHUB_RUN_ID}\"; echo \"- Event: ${GITHUB_EVENT_NAME}\"; echo \"- Issue: ${ISSUE_TAG}\"; echo; echo \"## Task Input (JSON)\"; echo \\\"```json\\\"; } > \"$REPORT\"; { echo \\\"```json\\\"; echo \"${{ steps.merge.outputs.task_input }}\"; echo \\\"```\\\"; echo; echo \"## Changes summary\"; echo; echo \"No code changes were necessary. This report file is added to satisfy the completion condition.\"; } >> \"$REPORT\"; echo \"synthesized=true\" >> \"$GITHUB_OUTPUT\"; echo \"report_path=${REPORT}\" >> \"$GITHUB_OUTPUT\"'"
      - name: Group and commit Codex changes
        if: ${{ steps.detect.outputs.run_codex == 'true' && steps.clarifications.outputs.needs_clarification != 'true' && (steps.diff.outputs.changed == 'true' || steps.synth.outputs.synthesized == 'true') }}
        id: grouped_commits
        env:
          BRANCH_NAME: ${{ github.event_name == 'issue_comment' && steps.detect.outputs.issue_number != '' && format('codex/issue-{0}', steps.detect.outputs.issue_number) || format('codex/run-{0}', github.run_id) }}
          BRANCH_EXISTS: ${{ steps.prepare_branch.outputs.exists || 'false' }}
          ISSUE_NUMBER: ${{ steps.detect.outputs.issue_number }}
          ISSUE_TITLE: ${{ github.event.issue.title || '' }}
          CHANGE_SUMMARY: ${{ steps.summary.outputs.change_summary }}
        run: "bash -lc $'set -euo pipefail; python3 -c \"import sys, textwrap; exec(textwrap.dedent(sys.stdin.read()))\" <<\\'PY\\nimport os, subprocess\\n\\ndef run(cmd, *, capture=False):\\n    if capture:\\n        r = subprocess.run(cmd, check=True, stdout=subprocess.PIPE, text=True)\\n        return r.stdout\\n    subprocess.run(cmd, check=True)\\n\\nbranch = os.environ[\\'BRANCH_NAME\\']\\nbranch_exists = os.environ.get(\\'BRANCH_EXISTS\\', \\'false\\').lower() == \\'true\\'\\nissue_number = (os.environ.get(\\'ISSUE_NUMBER\\') or \\'\\').strip()\\nissue_title_raw = (os.environ.get(\\'ISSUE_TITLE\\') or \\'\\').strip()\\nchange_summary = (os.environ.get(\\'CHANGE_SUMMARY\\') or \\'\\').strip()\\nrun([\\'git\\', \\'restore\\', \\'--staged\\', \\'\\.\\'])\\nstatus_output = run([\\'git\\', \\'status\\', \\'--porcelain\\'], capture=True).strip()\\nif not status_output:\\n    print(\\'::notice::No files to commit.\\'); raise SystemExit(0)\\ncandidates = []\\nfor raw_line in status_output.splitlines():\\n    line = raw_line.rstrip()\\n    if not line: continue\\n    status = line[:2]\\n    remainder = line[2:].lstrip()\\n    if not remainder: continue\\n    if (\\'R\\' in status or \\'C\\' in status) and \\' -> \\' in remainder:\\n        paths_to_add = [part.strip() for part in remainder.split(\\' -> \\' , 1) if part.strip()]\\n    else:\\n        paths_to_add = [remainder.strip()]\\n    for candidate in paths_to_add:\\n        if candidate: candidates.append(candidate)\\nfiles = []\\nseen = set()\\nfor c in candidates:\\n    if c not in seen:\\n        seen.add(c); files.append(c)\\nif not files:\\n    print(\\'::notice::No files to commit.\\'); raise SystemExit(0)\\n\\ndef group_key(p: str) -> str:\\n    if \\'/\\' not in p: return \\'root\\'\\n    head = p.split(\\'\\/\\', 1)[0]\\n    return head if head in {\\'backend\\', \\'frontend\\', \\'docs\\', \\'prompts\\', \\'scripts\\'} else \\'others\\'\\n\\ngroups = {}\\nfor p in files:\\n    k = group_key(p)\\n    groups.setdefault(k, []).append(p)\\norder = [\\'docs\\', \\'frontend\\', \\'backend\\', \\'prompts\\', \\'scripts\\', \\'root\\', \\'others\\']\\nfor k in list(groups): groups[k].sort()\\nordered_keys = [k for k in order if k in groups] + [k for k in sorted(groups) if k not in order]\\n\\ndef adjust_length(t: str) -> str:\\n    fillers = [\\n        \\u81EA\\u52D5\\u30C6\\u30B9\\u30C8\\u3084\\u30B9\\u30BF\\u30A4\\u30EB\\u30C1\\u30A7\\u30C3\\u30AF\\u306E\\u57FA\\u6E96\\u3068\\u3082\\u6574\\u5408\\u3059\\u308B\\u7C92\\u5EA6\\u3067\\u5DEE\\u5206\\u3092\\u675F\\u306D\\u3066\\u3044\\u307E\\u3059\\u3002,\\n        \\u4F9D\\u5B58\\u30E2\\u30B8\\u30E5\\u30FC\\u30EB\\u3084\\u53C2\\u8003\\u8CC7\\u6599\\u3078\\u306E\\u5F71\\u97FF\\u3082\\u540C\\u3058\\u30B3\\u30DF\\u30C3\\u30C8\\u5185\\u3067\\u8FFD\\u8DE1\\u3067\\u304D\\u308B\\u3088\\u3046\\u88DC\\u8DB3\\u3057\\u307E\\u3057\\u305F\\u3002,\\n        \\u30EC\\u30D3\\u30E5\\u30A2\\u30FC\\u304C\\u5B89\\u5FC3\\u3057\\u3066\\u5224\\u65AD\\u3067\\u304D\\u308B\\u3060\\u3051\\u306E\\u6587\\u8108\\u60C5\\u5831\\u3092\\u610F\\u8B58\\u7684\\u306B\\u4FDD\\u6301\\u3057\\u3066\\u3044\\u307E\\u3059\\u3002\\n    ]\\n    while len(t) < 200 and fillers:\\n        t += fillers.pop(0)\\n    if len(t) > 300: t = t[:297] + \\'...\\'\\n    return t\\n\\nlabel_map = {\\n    \\'backend\\': \\'\\u30D0\\u30C3\\u30AF\\u30A8\\u30F3\\u30C9\\u9818\\u57DF\\', \\'frontend\\': \\'\\u30D5\\u30ED\\u30F3\\u30C8\\u30A8\\u30F3\\u30C9\\u9818\\u57DF\\', \\'docs\\': \\'\\u30C9\\u30AD\\u30E5\\u30E1\\u30F3\\u30C8\\u9818\\u57DF\\', \\'prompts\\': \\'\\u30D7\\u30ED\\u30F3\\u30D7\\u30C8\\u8A2D\\u5B9A\\u9818\\u57DF\\', \\'scripts\\': \\'\\u30B9\\u30AF\\u30EA\\u30D7\\u30C8\\u9818\\u57DF\\', \\'root\\': \\'\\u30EA\\u30DD\\u30B8\\u30C8\\u30EA\\u76F4\\u4E0B\\', \\'others\\': \\'\\u6A2A\\u65AD\\u9818\\u57DF\\'\\n}\\nissue_ref = f\\'#{issue_number}\\' if issue_number.isdigit() else \\'\\u8A72\\u5F53Issue\\u306A\\u3057\\'\\nfrag = issue_title_raw.replace(\\'\\\\r\\', \\\" \\\" ).replace(\\'\\\\n\\', \\\" \\\" ).strip() or \\'Codex\\u81EA\\u52D5\\u5B9F\\u884C\\u30BF\\u30B9\\u30AF\\'\\nif len(frag) > 60: frag = frag[:57] + \\'…\\'\\nfor k in ordered_keys:\\n    paths = groups[k]\\n    run([\\'git\\', \\'restore\\', \\'--staged\\', \\'\\.\\'])\\n    run([\\'git\\', \\'add\\', \\'-A\\', \\'--\\'] + paths)\\n    group_label = label_map.get(k, f\\'{k}\\u9818\\u57DF\\')\\n    sample_limit = 4\\n    sample = paths[:sample_limit]\\n    if len(paths) > sample_limit: sample.append(\\'\\u305D\\u306E\\u4ED6\\')\\n    file_digest = \\u3001.join(sample) if sample else \\'\\u5BFE\\u8C61\\u30D5\\u30A1\\u30A4\\u30EB\\'\\n    file_count = len(paths)\\n    content = (f\\'{group_label}\\u3067\\u691C\\u51FA\\u3057\\u305F{file_count}\\u4EF6\\u306E\\u30D5\\u30A1\\u30A4\\u30EB\\u5DEE\\u5206\\u3092\\u307E\\u3068\\u3081\\u3066\\u9069\\u7528\\u3057\\u3001\\u81EA\\u52D5\\u751F\\u6210\\u3055\\u308C\\u305F\\u5909\\u66F4\\u3092\\u69CB\\u9020\\u5358\\u4F4D\\u3067\\u6574\\u7406\\u3057\\u307E\\u3057\\u305F\\u3002\\'\\n               f\\'\\u4E3B\\u8981\\u30D5\\u30A1\\u30A4\\u30EB\\u306F{file_digest}\\u3067\\u3001\\u95A2\\u9023\\u3059\\u308B\\u8A2D\\u5B9A\\u3084\\u88DC\\u52A9\\u30B3\\u30FC\\u30C9\\u3082\\u540C\\u3058\\u30B3\\u30DF\\u30C3\\u30C8\\u5185\\u3067\\u6574\\u5408\\u6027\\u3092\\u4FDD\\u3064\\u3088\\u3046\\u540C\\u671F\\u3057\\u3066\\u3044\\u307E\\u3059\\u3002\\'\\n               \\u30EC\\u30D3\\u30E5\\u30FC\\u6642\\u306B\\u5909\\u66F4\\u610F\\u56F3\\u3092\\u8FFD\\u3044\\u3084\\u3059\\u3044\\u3088\\u3046\\u3001\\u4F9D\\u5B58\\u95A2\\u4FC2\\u3068\\u88DC\\u52A9\\u8CC7\\u6599\\u3092\\u540C\\u3058\\u30B3\\u30DF\\u30C3\\u30C8\\u306B\\u675F\\u306D\\u3066\\u3044\\u307E\\u3059\\u3002')\\n    if change_summary: content += '\\u5DEE\\u5206\\u6982\\u8981\\u306F\\u81EA\\u52D5\\u751F\\u6210\\u3057\\u305F\\u30B5\\u30DE\\u30EA\\u306B\\u57FA\\u3065\\u304D\\u3001\\u904E\\u4E0D\\u8DB3\\u304C\\u306A\\u3044\\u304B\\u3092\\u518D\\u78BA\\u8A8D\\u6E08\\u307F\\u3067\\u3059\\u3002'\\n    content = adjust_length(content)\\n    issue_fragment = f\\'\\u95A2\\u9023Issue {issue_ref} \\u306E\\u89E3\\u6C7A\\' if issue_number else \\u300C\\u624B\\u52D5\\u8D77\\u52D5\\u30BF\\u30B9\\u30AF\\u306E\\u8981\\u4EF6\\u5145\\u8DB3\\u300D\\n    purpose = (f\\'\\u81EA\\u52D5\\u5316\\u30EF\\u30FC\\u30AF\\u30D5\\u30ED\\u30FC\\u304C\\u63D0\\u6848\\u3057\\u305F{group_label}\\u306E\\u4FEE\\u6B63\\u3092\\u6BB5\\u968E\\u7684\\u306B\\u5171\\u6709\\u3057\\u3001\\u30EC\\u30D3\\u30E5\\u30A2\\u30FC\\u304C\\u5F71\\u97FF\\u7BC4\\u56F2\\u3092\\u773A\\u3081\\u308B\\u3053\\u3068\\u304C\\u72D9\\u3044\\u3067\\u3059\\u3002\\'\\n               f\\'{issue_fragment}\\u3068\\u300C{frag}\\u300D\\u306E\\u80CC\\u666F\\u3092\\u8踏\\u307E\\u3048\\u3001\\u5F8C\\u7D9A\\u5BFE\\u5FDC\\u3084\\u56DE\\u5FA9\\u691C\\u8A3C\\u3078\\u306E\\u6A2A\\u6E21\\u3057\\u3068\\u306A\\u308B\\u60C5\\u5831\\u3092\\u78BA\\u4FDD\\u3059\\u308B\\u305F\\u3081\\u306B\\u3053\\u306E\\u30B3\\u30DF\\u30C3\\u30C8\\u5358\\u4F4D\\u3067\\u4FDD\\u5B58\\u3057\\u3066\\u3044\\u307E\\u3059\\u3002\\'\\n               \\u307E\\u305F\\u3001\\u30D3\\u30EB\\u30C9\\u3068\\u904B\\u7528\\u306B\\u5FC5\\u8981\\u306A\\u5468\\u8FBA\\u8A2D\\u5B9A\\u3092\\u5148\\u884C\\u3057\\u3066\\u6574\\u5099\\u3059\\u308B\\u3053\\u3068\\u3067\\u3001\\u8FFD\\u52A0\\u5BFE\\u5FDC\\u6642\\u306E\\u624B\\u623B\\u308A\\u3092\\u6291\\u3048\\u7D99\\u7D9A\\u7684\\u306A\\u6539\\u5584\\u30B5\\u30A4\\u30AF\\u30EB\\u3092\\u7DAD\\u6301\\u3059\\u308B\\u610F\\u56F3\\u304C\\u3042\\u308A\\u307E\\u3059\\u3002')\\n    purpose = adjust_length(purpose)\\n    msg = f\\'##変更内容\\n{content}\\n\\n##目的\\n{purpose}\\'\\n    run([\\'git\\', \\'commit\\', \\'-m\\', msg])\\nremaining = run([\\'git\\', \\'status\\', \\'--porcelain\\'], capture=True).strip()\\nif remaining: raise SystemExit(f\\'Uncommitted files remain:\\n{remaining}\\')\\nif branch_exists:\\n    run([\\'git\\', \\'push\\', \\'origin\\', f\\'HEAD:{branch}\\'])\\nelse:\\n    run([\\'git\\', \\'push\\', \\'-u\\', \\'origin\\', branch])\\nPY'"
      - name: Create or update pull request
        if: ${{ steps.detect.outputs.run_codex == 'true' && steps.clarifications.outputs.needs_clarification != 'true' && (steps.diff.outputs.changed == 'true' || steps.synth.outputs.synthesized == 'true') }}
        id: pr
        uses: actions/github-script@v7
        env:
          BRANCH_NAME: ${{ github.event_name == 'issue_comment' && steps.detect.outputs.issue_number != '' && format('codex/issue-{0}', steps.detect.outputs.issue_number) || format('codex/run-{0}', github.run_id) }}
          BASE_BRANCH: develop
          ISSUE_NUMBER: ${{ steps.detect.outputs.issue_number }}
          TASK_INPUT: ${{ steps.merge.outputs.task_input }}
          CHANGE_SUMMARY: ${{ steps.summary.outputs.change_summary }}
          REPORT_PATH: ${{ steps.synth.outputs.report_path }}
        with:
          script: |
            const branch = process.env.BRANCH_NAME;
            const base = process.env.BASE_BRANCH;
            const issueNumberRaw = process.env.ISSUE_NUMBER || '';
            const issueNumber = Number(issueNumberRaw);
            const changeSummary = (process.env.CHANGE_SUMMARY || '').trim();
            const reportPath = (process.env.REPORT_PATH || '').trim();
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const title = Number.isFinite(issueNumber) && issueNumber > 0 ? `Codex: issue #${issueNumber}` : 'Codex: manual run';
            const changesBlock = changeSummary || (reportPath ? `No code changes were necessary. A report file was added: ${reportPath}` : 'No code changes were necessary. A report file is included under .codex/reports/');
            const body = ['Task input (JSON):','','```json',`${process.env.TASK_INPUT || ''}`,'```','','Changes summary:','```text',changesBlock,'```'].join('\n');
            const headRef = `${owner}:${branch}`;
            const existing = await github.rest.pulls.list({ owner, repo, head: headRef, state: 'open', per_page: 1 });
            if (existing.data.length > 0) {
              const pr = existing.data[0];
              await github.rest.pulls.update({ owner, repo, pull_number: pr.number, title, body });
              core.setOutput('pull_request_number', pr.number);
              core.setOutput('pull_request_url', pr.html_url);
            } else {
              const pr = await github.rest.pulls.create({ owner, repo, head: branch, base, title, body, maintainer_can_modify: true });
              core.setOutput('pull_request_number', pr.number);
              core.setOutput('pull_request_url', pr.html_url);
            }
      - name: Comment work report to issue
        if: ${{ steps.detect.outputs.run_codex == 'true' && steps.clarifications.outputs.needs_clarification != 'true' && (steps.diff.outputs.changed == 'true' || steps.synth.outputs.synthesized == 'true') && github.event_name == 'issue_comment' }}
        uses: actions/github-script@v7
        env:
          CHANGE_SUMMARY: ${{ steps.summary.outputs.change_summary }}
          REPORT_PATH: ${{ steps.synth.outputs.report_path }}
        with:
          script: |
            const fs = require('fs');
            const issueNumber = Number("${{ steps.detect.outputs.issue_number }}");
            const prUrl = "${{ steps.pr.outputs.result.pull_request_url }}";
            const prNumber = Number("${{ steps.pr.outputs.result.pull_request_number }}");
            const changeSummary = (process.env.CHANGE_SUMMARY || '').trim();
            const reportPath = (process.env.REPORT_PATH || '').trim();
            const summaryBlock = changeSummary ? changeSummary : `差分はありません。${reportPath ? `レポートファイル: ${reportPath}` : ''}`.trim();
            const issueTitle = (context.payload.issue && context.payload.issue.title || '').trim();
            const relatedIssue = Number.isFinite(issueNumber) && issueNumber > 0 ? `#${issueNumber}` : "N/A";
            const prInfoSuffix = Number.isFinite(prNumber) && prNumber > 0 ? `（PR: #${prNumber}）` : "";
            const purpose = issueTitle ? `${issueTitle}${prInfoSuffix}` : `自動対応タスク${prInfoSuffix}`;
            const artifactNote = "成果物: ワークフローアーティファクト `codex-agent-outputs`";
            const summaryLines = [Number.isFinite(prNumber) && prNumber > 0 ? `PR: #${prNumber} (${prUrl})` : null, artifactNote, summaryBlock].filter(Boolean).join("\n");
            const apiDbImpact = /(\/api\/|\.sql\b|db|database|schema|migration|prisma|datasource)/i.test(summaryLines) ? "変更あり（自動推定・要確認）" : "変更なし（自動推定）";
            const fallbackReport = ["## 背景",`- 目的: ${purpose}`,`- 関連: ${relatedIssue}`,"","## 変更概要","- 要約:","```text",summaryLines,"```","","## 影響","",`- API/DB: ${apiDbImpact}`,"- セキュリティ・パフォーマンスへの影響: 未評価（自動コメント）","","## 検証","- テスト: 追加0件、カバレッジN/A（自動コメント）","","## レビュー観点","- 重点: 差分とPR内容の妥当性を確認してください。","- 非対象: 特になし"].join("\n");
            const workReportPath = 'codex_output/work_report.md';
            const report = fs.existsSync(workReportPath) ? (fs.readFileSync(workReportPath, 'utf8').trim() || fallbackReport) : fallbackReport;
            await github.rest.issues.createComment({ owner: context.repo.owner, repo: context.repo.repo, issue_number: issueNumber, body: report });
      - name: Enforce completion condition
        if: ${{ steps.detect.outputs.run_codex == 'true' && steps.clarifications.outputs.needs_clarification != 'true' && (steps.diff.outputs.changed != 'true' && steps.synth.outputs.synthesized != 'true') }}
        run: "bash -lc $'echo \"::error::No changes detected. PR was not created, so completion conditions are not met.\"; exit 1'"

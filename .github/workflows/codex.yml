# .github/workflows/codex.yml
name: Codex Auto Dev

on:
  workflow_dispatch:
    inputs:
      task_input:
        description: Task text passed to the Codex pipeline (defaults if omitted)
        required: false
  issue_comment:
    types: [created, edited]

concurrency:
  group: codex-auto-dev-${{ github.event_name }}-${{ github.event.issue.number || github.ref || 'manual' }}
  cancel-in-progress: true

permissions:
  contents: write
  issues: write
  pull-requests: write

jobs:
  codex:
    if: >-
      github.event_name == 'workflow_dispatch' ||
      (github.event_name == 'issue_comment' &&
       contains(fromJson('["OWNER","MEMBER","COLLABORATOR"]'), github.event.comment.author_association))
    runs-on: ubuntu-latest
    timeout-minutes: 30
    env:
      CODEX_NPM_PKG: "@openai/codex"

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Detect trigger and compose TASK_INPUT
        id: detect
        env:
          GITHUB_EVENT_NAME: ${{ github.event_name }}
          GITHUB_EVENT_PATH: ${{ github.event_path }}
        run: |
          set -euo pipefail
          python3 - <<'PY'
          import json, os, re, sys, uuid

          name = os.environ.get("GITHUB_EVENT_NAME","")
          path = os.environ.get("GITHUB_EVENT_PATH")
          if not path:
              print("::error::GITHUB_EVENT_PATH is not set."); sys.exit(1)
          with open(path, encoding="utf-8") as f:
              event = json.load(f)

          def out(k, v):
              go = os.environ["GITHUB_OUTPUT"]
              if "\n" in v:
                  m = f"EOF_{uuid.uuid4().hex}"
                  with open(go, "a", encoding="utf-8") as g:
                      g.write(f"{k}<<{m}\n{v}\n{m}\n")
              else:
                  with open(go, "a", encoding="utf-8") as g:
                      g.write(f"{k}={v}\n")

          def coerce(x): return "" if x is None else str(x)

          if name == "workflow_dispatch":
              inputs = event.get("inputs") or {}
              task = coerce(inputs.get("task_input")).strip() or "Manual trigger: Please implement the requested feature."
              out("run_codex","true")
              out("task_input", task)

          elif name == "issue_comment":
              issue = event.get("issue") or {}
              comment = event.get("comment") or {}
              title = coerce(issue.get("title")).strip()
              issue_body = coerce(issue.get("body")).strip()
              body = coerce(comment.get("body")).replace("\r","")

              # Require @CODEX_AGENTS at the first non-empty line
              lines = body.split("\n")
              i = 0
              while i < len(lines) and lines[i].strip() == "":
                  i += 1
              if i == len(lines):
                  out("run_codex","false"); sys.exit(0)

              first = lines[i].lstrip()
              if not first.startswith("@CODEX_AGENTS"):
                  out("run_codex","false"); sys.exit(0)

              head = first[len("@CODEX_AGENTS"):].lstrip(" \t:-")
              command = ("\n".join([head] + lines[i+1:])).strip()

              # Allow empty command: pass literal "" so quoting is safe
              if not command:
                  command = '""'

              policy = (
                  "You MUST follow these constraints:\n"
                  "1. Avoid creating unnecessary tasks and keep impact on the existing project to a minimum.\n"
                  "2. Complete all required fixes to deliver a finished, self-contained outcome."
              )
              augmented_command = f"{command}\n\n{policy}".strip()

              payload = json.dumps({
                  "Issue Title": title,
                  "Issue Body": issue_body,
                  "Instruction": augmented_command
              }, ensure_ascii=False)

              out("run_codex","true")
              out("task_input", payload)
              out("issue_number", coerce(issue.get("number")))
          else:
              print("::error::Unsupported event."); sys.exit(1)

          prev = (locals().get("payload") or locals().get("task") or "").replace("\n"," ").replace("\r"," ")
          if prev:
              print(f"TASK_INPUT preview: {prev[:200]}{'...' if len(prev)>200 else ''}")
          PY

      - name: Install Codex CLI
        if: ${{ steps.detect.outputs.run_codex == 'true' }}
        run: |
          npm i -g ${CODEX_NPM_PKG:-@openai/codex}@0.39.0
          codex --version

      - name: Restore ChatGPT auth (no API key)
        if: ${{ steps.detect.outputs.run_codex == 'true' }}
        env:
          CODEX_AUTH_JSON_B64: ${{ secrets.CODEX_AUTH_JSON_B64 }}
        run: |
          set -euo pipefail
          test -n "${CODEX_AUTH_JSON_B64:-}" || { echo "::error::Missing secret CODEX_AUTH_JSON_B64"; exit 1; }
          mkdir -p "$HOME/.codex"
          printf '%s' "$CODEX_AUTH_JSON_B64" | base64 -d > "$HOME/.codex/auth.json"
          chmod 600 "$HOME/.codex/auth.json"
          echo 'preferred_auth_method = "chatgpt"' > "$HOME/.codex/config.toml"
          codex --version

      - name: Run Codex pipeline
        if: ${{ steps.detect.outputs.run_codex == 'true' }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          mkdir -p codex_output
          ./scripts/run_codex_pipeline.sh <<'JSON'
          ${{ steps.detect.outputs.task_input }}
          JSON

      - name: Check for clarification request
        if: ${{ steps.detect.outputs.run_codex == 'true' }}
        id: clarifications
        run: |
          set -euo pipefail
          python3 - <<'PY'
          import json, pathlib, re, sys, textwrap
          needs = False
          questions = ""

          # 1) status.json contract (preferred)
          p = pathlib.Path("codex_output/status.json")
          if p.exists():
              try:
                  data = json.loads(p.read_text(encoding="utf-8"))
                  if data.get("status") == "needs_clarification":
                      needs = True
                      qf = pathlib.Path("codex_output/clarifying_questions.md")
                      if qf.exists():
                          questions = qf.read_text(encoding="utf-8").strip()
              except Exception:
                  pass

          # 2) Heuristic on translator.md (fallback)
          if not needs:
              t = pathlib.Path("codex_output/translator.md")
              if t.exists():
                  txt = t.read_text(encoding="utf-8")
                  if re.search(r'(?i)\b(questions?|needs? clarification|clarifications?)\b', txt):
                      needs = True
                      m = re.search(r'(?is)^(?:#+\s*)?(?:Open\s+)?Questions?:\s*\n(.*?)(?:\n#+\s|\Z)', txt, re.M)
                      if m:
                          questions = m.group(1).strip()
                      else:
                          # Fallback: provide the whole translator output (truncated)
                          questions = textwrap.shorten(txt.strip().replace("\r",""), width=4000, placeholder="â€¦")

          # Emit outputs
          print(f"needs_clarification={'true' if needs else 'false'}")
          if needs:
              print("questions<<EOF")
              print(questions or "- (No specific questions were extracted. Please restate details.)")
              print("EOF")
          PY

      - name: Upload Codex outputs
        if: ${{ steps.detect.outputs.run_codex == 'true' }}
        uses: actions/upload-artifact@v4
        with:
          name: codex-agent-outputs
          path: codex_output
          retention-days: 7

      - name: Check repository diff
        if: ${{ steps.detect.outputs.run_codex == 'true' }}
        id: diff
        run: |
          set -euo pipefail
          if [ -z "$(git status --porcelain)" ]; then
            echo "changed=false" >> "$GITHUB_OUTPUT"
          else
            echo "changed=true" >> "$GITHUB_OUTPUT"
          fi

      - name: Request additional details on issue
        if: ${{ steps.detect.outputs.run_codex == 'true' && steps.clarifications.outputs.needs_clarification == 'true' && github.event_name == 'issue_comment' }}
        uses: actions/github-script@v7
        env:
          ISSUE_NUMBER: ${{ steps.detect.outputs.issue_number }}
          QUESTIONS: ${{ steps.clarifications.outputs.questions }}
        with:
          script: |
            const issueNumber = Number(process.env.ISSUE_NUMBER);
            const questions = (process.env.QUESTIONS || '').trim();
            const body = [
              'Codex needs more information to proceed with the automated workflow.',
              '',
              'Please provide answers to the following questions:',
              '',
              questions || '- (No questions captured, please restate your request with additional details.)',
              '',
              '_Reply starting with `@CODEX_AGENTS` once you have responded so the workflow can continue._'
            ].join('\n');
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber,
              body
            });

      - name: Surface clarification need
        if: ${{ steps.detect.outputs.run_codex == 'true' && steps.clarifications.outputs.needs_clarification == 'true' && github.event_name != 'issue_comment' }}
        run: |
          echo "Codex requested clarifying information. Please review codex_output/clarifying_questions.md or translator.md."

      - name: Create Pull Request
        if: ${{ steps.detect.outputs.run_codex == 'true' && steps.clarifications.outputs.needs_clarification != 'true' && steps.diff.outputs.changed == 'true' }}
        id: cpr
        uses: peter-evans/create-pull-request@v6
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          branch: ${{ github.event_name == 'issue_comment' && format('codex/issue-{0}', steps.detect.outputs.issue_number) || format('codex/run-{0}', github.run_id) }}
          base: ${{ github.event.repository.default_branch }}
          commit-message: "chore(codex): apply generated changes"
          title: "${{ github.event_name == 'issue_comment' && format('Codex: issue #{0}', steps.detect.outputs.issue_number) || 'Codex: manual run' }}"
          body: |
            Task input (JSON):

            ${{ steps.detect.outputs.task_input }}
          delete-branch: true

      - name: Comment work report to issue
        if: ${{ steps.detect.outputs.run_codex == 'true' && steps.clarifications.outputs.needs_clarification != 'true' && steps.diff.outputs.changed == 'true' && github.event_name == 'issue_comment' }}
        uses: actions/github-script@v7
        with:
          script: |
            const issue_number = Number("${{ steps.detect.outputs.issue_number }}");
            const prUrl = "${{ steps.cpr.outputs['pull-request-url'] }}";
            const prNumber = Number("${{ steps.cpr.outputs['pull-request-number'] }}");
            const body = [
              "Automated work completed by Codex.",
              "",
              `- Created/updated PR: #${prNumber} (${prUrl})`,
              "- Artifacts: attached as workflow artifact `codex-agent-outputs`",
              "",
              "Task input (JSON):",
              "```json",
              `${{ steps.detect.outputs.task_input }}`,
              "```"
            ].join("\n");
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number,
              body
            });

      - name: Enforce completion condition
        if: ${{ steps.detect.outputs.run_codex == 'true' && steps.clarifications.outputs.needs_clarification != 'true' && steps.diff.outputs.changed != 'true' }}
        run: |
          echo "::error::No changes detected. PR was not created, so completion conditions are not met."
          exit 1

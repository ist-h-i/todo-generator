# .github/workflows/codex.yml
name: Codex Auto Dev

on:
  workflow_dispatch:
    inputs:
      task_input:
        description: Task text passed to the Codex pipeline (defaults if omitted)
        required: false
  issue_comment:
    types: [created, edited]

concurrency:
  group: codex-auto-dev-${{ github.event_name }}-${{ github.event.issue.number || github.ref || 'manual' }}
  cancel-in-progress: true

permissions:
  contents: write
  issues: write
  pull-requests: write

jobs:
  codex:
    if: >-
      github.event_name == 'workflow_dispatch' ||
      (github.event_name == 'issue_comment' &&
       contains(fromJson('["OWNER","MEMBER","COLLABORATOR"]'), github.event.comment.author_association))
    runs-on: ubuntu-latest
    timeout-minutes: 30
    env:
      CODEX_NPM_PKG: "@openai/codex"

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Detect trigger and compose TASK_INPUT
        id: detect
        env:
          GITHUB_EVENT_NAME: ${{ github.event_name }}
          GITHUB_EVENT_PATH: ${{ github.event_path }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          python3 - <<'PY'
          import json, os, sys, uuid, urllib.request

          name = os.environ.get("GITHUB_EVENT_NAME","")
          path = os.environ.get("GITHUB_EVENT_PATH")
          if not path:
              print("::error::GITHUB_EVENT_PATH is not set."); sys.exit(1)
          with open(path, encoding="utf-8") as f:
              event = json.load(f)

          def out(k, v):
              go = os.environ["GITHUB_OUTPUT"]
              if "\n" in v:
                  m = f"EOF_{uuid.uuid4().hex}"
                  with open(go, "a", encoding="utf-8") as g:
                      g.write(f"{k}<<{m}\n{v}\n{m}\n")
              else:
                  with open(go, "a", encoding="utf-8") as g:
                      g.write(f"{k}={v}\n")

          def coerce(x):
              return "" if x is None else str(x)

          if name == "workflow_dispatch":
              inputs = event.get("inputs") or {}
              task = coerce(inputs.get("task_input")).strip() or "Manual trigger: Please implement the requested feature."
              out("run_codex","true")
              out("task_input", task)

          elif name == "issue_comment":
              issue = event.get("issue") or {}
              comment = event.get("comment") or {}
              title = coerce(issue.get("title")).strip()
              issue_body = coerce(issue.get("body")).strip()
              body = coerce(comment.get("body")).replace("\r","")

              lines = body.split("\n")
              trigger_token = "@codex_agents"
              trigger_index = -1
              trigger_line = ""
              for idx, raw in enumerate(lines):
                  stripped = raw.strip()
                  if not stripped:
                      continue
                  probe = stripped
                  while probe.startswith(">"):
                      probe = probe[1:].lstrip()
                  if probe.lower().startswith(trigger_token):
                      trigger_index = idx
                      trigger_line = probe
                      break
              if trigger_index < 0:
                  out("run_codex","false"); sys.exit(0)

              head = trigger_line[len(trigger_token):].lstrip(" \t:-")
              command = ("\n".join([head] + lines[trigger_index+1:])).strip()
              if not command:
                  command = '""'
              policy = (
                  "You MUST follow these constraints:\n"
                  "1. Avoid creating unnecessary tasks and keep impact on the existing project to a minimum.\n"
                  "2. Complete all required fixes to deliver a finished, self-contained outcome."
              )
              augmented_command = f"{command}\n\n{policy}".strip()

              # Recent conversation snapshot (last 15 comments, clipped)
              def fetch_issue_comments(ev, limit=15, clip=800):
                  repo = (ev.get("repository") or {})
                  owner = ((repo.get("owner") or {}).get("login")) or ""
                  name  = repo.get("name") or ""
                  num   = issue.get("number")
                  if not (owner and name and num):
                      return []
                  url = f"https://api.github.com/repos/{owner}/{name}/issues/{num}/comments?per_page=100"
                  headers = {"Accept":"application/vnd.github+json"}
                  tok = os.environ.get("GITHUB_TOKEN","")
                  if tok:
                      headers["Authorization"] = f"Bearer {tok}"
                  req = urllib.request.Request(url, headers=headers)
                  try:
                      with urllib.request.urlopen(req, timeout=30) as r:
                          arr = json.loads(r.read().decode("utf-8"))
                  except Exception as e:
                      print(f"::warning::Failed to fetch comments: {e}")
                      return []
                  arr = arr[-limit:]
                  out_items = []
                  for c in arr:
                      by = ((c.get("user") or {}).get("login")) or ""
                      at = c.get("created_at") or ""
                      bd = (c.get("body") or "").strip()
                      if len(bd) > clip:
                          bd = bd[:clip] + " ...(truncated)"
                      out_items.append({"by":by, "at":at, "body":bd})
                  return out_items

              conversation = fetch_issue_comments(event)

              payload = json.dumps({
                  "Issue Title": title,
                  "Issue Body": issue_body,
                  "Instruction": augmented_command,
                  "Conversation": conversation
              }, ensure_ascii=False)

              out("run_codex","true")
              out("task_input", payload)
              out("issue_number", coerce(issue.get("number")))
          else:
              print("::error::Unsupported event."); sys.exit(1)

          prev = (locals().get("payload") or locals().get("task") or "").replace("\n"," ").replace("\r"," ")
          if prev:
              print(f"TASK_INPUT preview: {prev[:200]}{'...' if len(prev)>200 else ''}")
          PY

      - name: Load previous progress for this issue
        if: ${{ steps.detect.outputs.run_codex == 'true' && github.event_name == 'issue_comment' }}
        id: progress
        run: |
          set -euo pipefail
          num="${{ steps.detect.outputs.issue_number }}"
          if [ -z "${num}" ]; then
            echo "exists=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          git fetch origin "refs/heads/codex/issue-${num}:refs/remotes/origin/codex/issue-${num}" || true
          if git show "refs/remotes/origin/codex/issue-${num}:.codex/state/issue-${num}/progress.json" >/dev/null 2>&1; then
            content="$(git show "refs/remotes/origin/codex/issue-${num}:.codex/state/issue-${num}/progress.json" || true)"
            if [ -n "$content" ]; then
              {
                echo "json<<EOF"
                echo "$content"
                echo "EOF"
              } >> "$GITHUB_OUTPUT"
              echo "exists=true" >> "$GITHUB_OUTPUT"
            else
              echo "exists=false" >> "$GITHUB_OUTPUT"
            fi
          else
            echo "exists=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Merge previous progress into TASK_INPUT
        if: ${{ steps.detect.outputs.run_codex == 'true' }}
        id: merge
        env:
          INPUT_JSON: ${{ steps.detect.outputs.task_input }}
          PREV: ${{ steps.progress.outputs.json }}
        run: |
          set -euo pipefail
          merged="$(python3 - <<'PY'
          import json, os, sys
          task=os.environ.get("INPUT_JSON","")
          prev=os.environ.get("PREV","")
          try:
            data=json.loads(task)
          except Exception:
            # Fallback for workflow_dispatch plain string
            data={"Instruction": task}
          if prev:
            try:
              data["PreviousProgress"]=json.loads(prev)
            except Exception:
              data["PreviousProgressRaw"]=prev
          print(json.dumps(data, ensure_ascii=False))
          PY
          )"
          {
            echo "task_input<<EOF"
            echo "${merged}"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

      - name: Install Codex CLI
        if: ${{ steps.detect.outputs.run_codex == 'true' }}
        run: |
          npm i -g ${CODEX_NPM_PKG:-@openai/codex}@0.39.0
          codex --version

      - name: Restore ChatGPT auth (no API key)
        if: ${{ steps.detect.outputs.run_codex == 'true' }}
        env:
          CODEX_AUTH_JSON_B64: ${{ secrets.CODEX_AUTH_JSON_B64 }}
        run: |
          set -euo pipefail
          test -n "${CODEX_AUTH_JSON_B64:-}" || { echo "::error::Missing secret CODEX_AUTH_JSON_B64"; exit 1; }
          mkdir -p "$HOME/.codex"
          printf '%s' "$CODEX_AUTH_JSON_B64" | base64 -d > "$HOME/.codex/auth.json"
          chmod 600 "$HOME/.codex/auth.json"
          echo 'preferred_auth_method = "chatgpt"' > "$HOME/.codex/config.toml"
          codex --version

      - name: Run Codex pipeline
        if: ${{ steps.detect.outputs.run_codex == 'true' }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          RUN_CODEX: ${{ steps.detect.outputs.run_codex }}
        run: |
          set -euo pipefail
          mkdir -p codex_output
          ./scripts/run_codex_pipeline.sh <<'JSON'
          ${{ steps.merge.outputs.task_input }}
          JSON

      - name: Check for clarification request
        if: ${{ steps.detect.outputs.run_codex == 'true' }}
        id: clarifications
        run: |
          set -euo pipefail
          status=""
          if [ -f codex_output/status.json ]; then
            status=$(python3 - <<'PY'
          import json, pathlib
          path = pathlib.Path("codex_output/status.json")
          data = json.loads(path.read_text(encoding="utf-8"))
          print(data.get("status", ""))
          PY
            )
          fi
          if [ "${status}" = "needs_clarification" ]; then
            echo "needs_clarification=true" >> "$GITHUB_OUTPUT"
            if [ -f codex_output/clarifying_questions.md ]; then
              {
                echo "questions<<EOF"
                cat codex_output/clarifying_questions.md
                echo "EOF"
              } >> "$GITHUB_OUTPUT"
            fi
          else
            echo "needs_clarification=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Persist progress snapshot
        if: ${{ steps.detect.outputs.run_codex == 'true' && github.event_name == 'issue_comment' }}
        id: persist
        env:
          ISSUE_NUMBER: ${{ steps.detect.outputs.issue_number }}
        run: |
          set -euo pipefail
          dir=".codex/state/issue-${ISSUE_NUMBER}"
          mkdir -p "$dir"
          ts="$(date -u +%Y-%m-%dT%H:%M:%SZ)"; export ts
          python3 - <<'PY'
          import os, json, pathlib, time
          issue=os.environ.get("ISSUE_NUMBER","manual")
          run_id=os.environ.get("GITHUB_RUN_ID","")
          ts=os.environ.get("ts","")
          out={"issue":issue,"run_id":run_id,"timestamp":ts}

          # status.json (structured if possible)
          p=pathlib.Path("codex_output/status.json")
          if p.exists():
            try:
              out["status"]=json.loads(p.read_text(encoding="utf-8"))
            except Exception:
              out["status_raw"]=p.read_text(encoding="utf-8")

          # clarifying questions preview
          q=pathlib.Path("codex_output/clarifying_questions.md")
          if q.exists():
            out["clarifying_questions"]=q.read_text(encoding="utf-8")[:4000]

          # file inventory with small previews
          files=[]
          base=pathlib.Path("codex_output")
          if base.exists():
            for q in base.rglob("*"):
              if q.is_file():
                sz=q.stat().st_size
                item={"path":str(q), "size":sz}
                if sz<=20000:
                  try:
                    item["preview"]=q.read_text(encoding="utf-8", errors="ignore")[:4000]
                  except Exception:
                    pass
                files.append(item)
          out["files"]=files

          d=pathlib.Path(f".codex/state/issue-{issue}")
          d.mkdir(parents=True, exist_ok=True)
          (d/"progress.json").write_text(json.dumps(out, ensure_ascii=False, indent=2), encoding="utf-8")
          print(str(d/"progress.json"))
          PY
          echo "path=$dir/progress.json" >> "$GITHUB_OUTPUT"

      - name: Debug gates
        if: ${{ steps.detect.outputs.run_codex == 'true' }}
        run: |
          echo "run_codex=${{ steps.detect.outputs.run_codex }}"
          echo "needs_clarification=${{ steps.clarifications.outputs.needs_clarification || 'n/a' }}"
          echo "progress_saved=${{ steps.persist.outputs.path || 'n/a' }}"

      - name: Comment clarifying questions to issue
        if: ${{ steps.detect.outputs.run_codex == 'true' && steps.clarifications.outputs.needs_clarification == 'true' && github.event_name == 'issue_comment' }}
        uses: actions/github-script@v7
        env:
          QUESTIONS: ${{ steps.clarifications.outputs.questions }}
        with:
          script: |
            const issue_number = Number("${{ steps.detect.outputs.issue_number }}");
            const questions = process.env.QUESTIONS || '(no questions found)';
            const body = [
              "Codex requires clarifications before continuing.",
              "",
              "### Questions",
              questions
            ].join("\n");
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number,
              body
            });

      - name: Stop after clarification
        if: ${{ steps.detect.outputs.run_codex == 'true' && steps.clarifications.outputs.needs_clarification == 'true' }}
        run: echo "::notice::Waiting for user clarifications." && exit 0

      - name: Upload Codex outputs
        if: ${{ steps.detect.outputs.run_codex == 'true' }}
        uses: actions/upload-artifact@v4
        with:
          name: codex-agent-outputs
          path: codex_output
          retention-days: 7

      - name: Check repository diff
        if: ${{ steps.detect.outputs.run_codex == 'true' }}
        id: diff
        run: |
          set -euo pipefail
          if [ -z "$(git status --porcelain)" ]; then
            echo "changed=false" >> "$GITHUB_OUTPUT"
          else
            echo "changed=true" >> "$GITHUB_OUTPUT"
          fi

      - name: Summarize changes
        if: ${{ steps.detect.outputs.run_codex == 'true' && steps.diff.outputs.changed == 'true' }}
        id: summary
        run: |
          set -euo pipefail
          files="$(git --no-pager diff --name-only)"
          stat="$(git --no-pager diff --stat)"
          count="$(printf "%s\n" "$files" | sed '/^$/d' | wc -l | tr -d ' ')"
          delim="EOF_$RANDOM$RANDOM"
          {
            echo "change_summary<<$delim"
            echo "Changed files ($count):"
            echo
            printf '%s\n' "$files" | sed 's/^/- /'
            echo
            echo "Diffstat:"
            echo
            printf '%s\n' "$stat"
            echo "$delim"
          } >> "$GITHUB_OUTPUT"

      - name: Synthesize report change if needed
        if: ${{ steps.detect.outputs.run_codex == 'true' && steps.diff.outputs.changed != 'true' }}
        id: synth
        env:
          ISSUE_NUMBER: ${{ steps.detect.outputs.issue_number }}
        run: |
          set -euo pipefail
          mkdir -p .codex/reports
          ISSUE_TAG="${ISSUE_NUMBER:-manual}"
          REPORT=".codex/reports/${ISSUE_TAG}-${GITHUB_RUN_ID}.md"
          {
            echo "# Codex Auto Dev Report"
            echo
            echo "- Run: ${GITHUB_RUN_ID}"
            echo "- Event: ${GITHUB_EVENT_NAME}"
            echo "- Issue: ${ISSUE_TAG}"
            echo
            echo "## Task Input (JSON)"
            echo '```json'
          } > "${REPORT}"
          cat <<'JSON' >> "${REPORT}"
          ${{ steps.merge.outputs.task_input }}
          JSON
          {
            echo '```'
            echo
            echo "## Changes summary"
            echo
            echo "No code changes were necessary. This report file is added to satisfy the completion condition."
          } >> "${REPORT}"
          echo "synthesized=true" >> "$GITHUB_OUTPUT"
          echo "report_path=${REPORT}" >> "$GITHUB_OUTPUT"

      - name: Create Pull Request
        if: ${{ steps.detect.outputs.run_codex == 'true' && steps.clarifications.outputs.needs_clarification != 'true' && (steps.diff.outputs.changed == 'true' || steps.synth.outputs.synthesized == 'true') }}
        id: cpr
        uses: peter-evans/create-pull-request@v6
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          branch: ${{ github.event_name == 'issue_comment' && format('codex/issue-{0}', steps.detect.outputs.issue_number) || format('codex/run-{0}', github.run_id) }}
          base: ${{ github.event.repository.default_branch }}
          commit-message: "chore(codex): persist progress and apply generated changes"
          title: "${{ github.event_name == 'issue_comment' && format('Codex: issue #{0}', steps.detect.outputs.issue_number) || 'Codex: manual run' }}"
          body: |
            Task input (JSON):

            ${{ steps.merge.outputs.task_input }}

            Changes summary:

            ```text
            ${{ steps.summary.outputs.change_summary || 'No code changes were necessary. A report file is included under .codex/reports/' }}
            ```
          delete-branch: true

      - name: Comment work report to issue
        if: ${{ steps.detect.outputs.run_codex == 'true' && steps.clarifications.outputs.needs_clarification != 'true' && (steps.diff.outputs.changed == 'true' || steps.synth.outputs.synthesized == 'true') && github.event_name == 'issue_comment' }}
        uses: actions/github-script@v7
        env:
          CHANGE_SUMMARY: ${{ steps.summary.outputs.change_summary }}
          REPORT_PATH: ${{ steps.synth.outputs.report_path }}
        with:
          script: |
            const issue_number = Number("${{ steps.detect.outputs.issue_number }}");
            const prUrl = "${{ steps.cpr.outputs['pull-request-url'] }}";
            const prNumber = Number("${{ steps.cpr.outputs['pull-request-number'] }}");
            const changeSummary = (process.env.CHANGE_SUMMARY || '').trim();
            const reportPath = (process.env.REPORT_PATH || '').trim();
            const summaryBlock = changeSummary ? changeSummary : `No code changes were necessary.${reportPath ? ` A report file was added: ${reportPath}` : ''}`;
            const body = [
              "Automated work completed by Codex.",
              "",
              `- Created/updated PR: #${prNumber} (${prUrl})`,
              "- Artifacts: attached as workflow artifact `codex-agent-outputs`",
              "",
              "Task input (JSON):",
              "```json",
              `${{ steps.merge.outputs.task_input }}`,
              "```",
              "",
              "Changes summary:",
              "```text",
              summaryBlock,
              "```"
            ].join("\n");
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number,
              body
            });

      - name: Enforce completion condition
        if: ${{ steps.detect.outputs.run_codex == 'true' && steps.clarifications.outputs.needs_clarification != 'true' && (steps.diff.outputs.changed != 'true' && steps.synth.outputs.synthesized != 'true') }}
        run: |
          echo "::error::No changes detected. PR was not created, so completion conditions are not met."
          exit 1

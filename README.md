# Todo Generator Requirements Definition

## 1. Project Overview
Todo Generator is a productivity support system that transforms unstructured user input (e.g., bug reports, mistake summaries, task ideas) into structured task cards. The application assists users by analyzing entered text with Gemini, extracting labels, priorities, and deadlines, and generating actionable subtasks. Users can review, adjust, and manage these cards through an interactive Angular-based interface backed by a Python service layer.

## 2. Objectives
- Provide a streamlined workflow for capturing free-form user input and translating it into organized task cards.
- Offer AI-assisted analysis (Gemini) to suggest labels, statuses, subtasks, due dates, and other task metadata.
- Enable intuitive drag-and-drop management of cards and subtasks, supporting collaborative planning workflows.
- Allow extensive user customization of statuses, labels, and card attributes to fit diverse project methodologies.

## 3. Key Personas & Use Cases
### 3.1 Product Managers
- Capture customer feedback summaries and quickly translate them into actionable work items.
- Prioritize tasks and share context with development teams via detailed card views.

### 3.2 Software Engineers
- Break down bug reports or technical debt tasks into subtasks generated by AI for quicker estimation and execution.
- Update progress via drag-and-drop status changes and card detail editing.

### 3.3 QA / Support Specialists
- Input error reports or ticket summaries and receive labeled cards grouped by issue type.
- Track resolution progress and adjust subtask statuses during testing cycles.

## 4. Functional Requirements
### 4.1 Input & AI Analysis
1. Accept raw text input describing issues, mistakes, or goals.
2. Send input to Gemini to extract:
   - Suggested task title, summary, and acceptance criteria.
   - Recommended labels, status, and story points.
   - Start and due dates inferred from context or defaults.
   - Subtask list with names, descriptions, and initial statuses.
3. Allow the user to review AI output before finalizing card creation.
4. Support multiple cards generated from a single input when Gemini detects distinct tasks.
5. Provide quick editing tools for all AI-generated fields (text, dropdowns, date pickers, number inputs).

### 4.2 Card Management
1. Display cards on a board view grouped by label (default) or other user-selected groupings (status, assignee, etc.).
2. Enable drag-and-drop reordering within a group and moving cards between groups to change status or label.
3. Offer free-form positioning within each group so users can arrange cards spatially.
4. Provide quick filters and search by label, status, assignee, or keyword.
5. Support inline editing of card title, label, and status from the board.
6. Persist board layout (positions and group settings) per user.

### 4.3 Card Detail View
1. Open a modal or full-screen drawer when a card is clicked.
2. Display complete details including description, AI rationale, created/updated timestamps, start/due dates, priority, story points, estimated effort, and dependencies.
3. Show subtask list styled similar to JIRA/Backlog, including status badges, assignees, due dates, and progress indicators.
4. Allow CRUD operations on subtasks (add, edit, delete) and drag-and-drop reordering within the detail view.
5. Provide activity log showing changes (status updates, field edits) with timestamps and author.
6. Offer comment threads with @mentions for collaboration.

### 4.4 Subtask Management
1. Each subtask includes: id, title, description, status, priority, assignee, start date, due date, estimate (hours), story points, and optional checklist items.
2. Gemini suggests initial subtasks, but users can add, modify, or remove subtasks at any time.
3. Subtask status updates should be draggable (e.g., todo/in-progress/done) via kanban-style lanes within the detail view.
4. Completion percentage for parent card is derived from subtask statuses.

### 4.5 Customization & Configuration
1. Users can create and edit custom labels, statuses, priorities, and workflows.
2. Allow creation of saved templates for common task types with predefined subtasks and metadata.
3. Provide workspace-level settings for default AI prompt templates, estimation scales, and label color palettes.
4. Support internationalization for UI labels and date formats.

### 4.6 Collaboration & Sharing
1. Multi-user authentication and authorization with role-based access (viewer, editor, admin).
2. Real-time updates via WebSockets or Server-Sent Events so multiple users can see card changes instantly.
3. Audit trails for all modifications with ability to export logs.

### 4.7 Reporting & Export
1. Generate summaries by label, status, or assignee with counts and completion percentages.
2. Export cards and subtasks to CSV/JSON for external reporting.
3. Provide burndown and velocity charts using story points and due dates.

## 5. Non-Functional Requirements
- **Performance:** Sub-200 ms response time for API calls under normal load; board interactions should feel instantaneous (<16ms frame budget).
- **Scalability:** Support teams of up to 200 active users with real-time collaboration and thousands of cards.
- **Reliability:** 99.5% uptime target with graceful degradation if Gemini API is unavailable (fall back to manual creation).
- **Security:** Enforce secure authentication (OAuth2/OpenID Connect), encrypt data in transit (HTTPS) and at rest, sanitize AI prompts, and log access.
- **Compliance:** GDPR-ready data handling including right-to-be-forgotten operations.

## 6. System Architecture
### 6.1 Frontend (Angular v20)
- SPA served from `frontend/` with Angular Material or custom UI kit.
- Feature modules:
  - Input Analyzer: form for entering user text and previewing AI output.
  - Board Module: draggable board with CDK DragDrop.
  - Card Detail Module: modal/drawer with tabs (Overview, Subtasks, Activity, Comments).
  - Settings Module: manage labels, statuses, templates, AI prompts.
- State management via NgRx or Angular signals for card data, board layouts, and user preferences.
- Routing for main board, analytics dashboard, and settings pages.
- Responsive design to support desktop and tablet usage; mobile view provides simplified list.

### 6.2 Backend (Python)
- FastAPI service hosted in `backend/`.
- RESTful API endpoints:
  - `POST /analysis`: submit raw input for Gemini processing and return structured card proposals.
  - `GET/POST/PUT/DELETE /cards`: CRUD operations on cards.
  - `GET/POST/PUT/DELETE /cards/{card_id}/subtasks`: manage subtasks.
  - `GET /labels`, `POST /labels`, etc. for customizable taxonomy.
  - `GET /board-layouts` and `PUT /board-layouts` for user-specific arrangements.
  - `POST /comments`, `GET /activity-log` for collaboration.
- Database layer using SQLAlchemy with SQLite/PostgreSQL; migrations handled via Alembic.
- Background tasks with Celery or FastAPI background jobs for scheduled reminders or batch exports.
- Authentication via OAuth2 with JWT tokens.
- Integration with Gemini service through dedicated client module handling prompt templates and retry logic.

### 6.3 Gemini Integration
- Standard prompt template combining user input with context (project settings, historical tasks).
- Post-processing pipeline to normalize Gemini output to system schemas, including confidence scores.
- Error handling and fallback flows for partial responses or API rate limits.
- Logging of prompts/responses with redaction for sensitive data.

## 7. Data Model
### 7.1 Card Entity
- `id` (UUID)
- `title`
- `summary`
- `description`
- `labels` (list of label IDs)
- `status`
- `priority`
- `storyPoints`
- `estimateHours`
- `assignees` (list of user IDs)
- `startDate`
- `dueDate`
- `createdAt`, `updatedAt`
- `dependencies` (list of card IDs)
- `aiConfidence` (0-1)
- `aiNotes` (reasoning, prompt metadata)
- `customFields` (key-value pairs)

### 7.2 Subtask Entity
- `id` (UUID)
- `cardId`
- `title`
- `description`
- `status`
- `priority`
- `assignee`
- `startDate`
- `dueDate`
- `estimateHours`
- `storyPoints`
- `checklist` (array of {id, label, done})
- `createdAt`, `updatedAt`

### 7.3 Label Entity
- `id` (UUID)
- `name`
- `color`
- `description`
- `isSystem`

### 7.4 Status Entity
- `id` (UUID)
- `name`
- `category` (todo/in-progress/done)
- `order`
- `color`
- `wipLimit`

### 7.5 User Preferences
- `userId`
- `boardGrouping`
- `boardLayout`
- `visibleFields`
- `notificationSettings`
- `preferredLanguage`

## 8. Workflow
1. User opens the Input Analyzer and enters textual description(s).
2. Frontend sends payload to backend `POST /analysis`.
3. Backend orchestrates Gemini prompt, receives proposed card(s), normalizes data, and returns to frontend.
4. User reviews proposals, edits metadata, and confirms card creation.
5. Cards appear on the board grouped by label; user drags cards to update statuses or reposition within groups.
6. Clicking a card opens the detail view where subtasks, comments, and history can be managed.
7. Backend persists changes and emits real-time updates to other clients.
8. Scheduled reminders and reports are generated based on due dates and story points.

## 9. Integration & Extensibility
- Webhooks for external integrations (Slack, Jira, GitHub) triggered on card creation or status changes.
- Import existing tasks from CSV or third-party systems, with optional Gemini reclassification.
- Plugin architecture for custom AI prompts or additional analytics dashboards.

## 10. Testing Strategy
- **Frontend:** Unit tests with Jasmine/Karma, component tests with Jest/Testing Library, e2e tests with Cypress or Playwright.
- **Backend:** Unit tests with pytest, integration tests for API endpoints, contract tests for Gemini client.
- **AI Validation:** Automated regression tests to compare Gemini output against golden datasets and ensure consistent labeling.
- **Performance:** Load testing for API endpoints and board interactions.

## 11. Deployment & DevOps
- CI/CD pipeline running linting, tests, and build steps for both frontend and backend.
- Containerized deployment using Docker Compose (frontend, backend, database, message broker).
- Environment-based configuration (dev/staging/prod) with secure management of Gemini API keys.
- Monitoring via Prometheus/Grafana and centralized logging.

## 12. Open Questions
- Determine pricing and usage quotas for Gemini API.
- Decide on primary database (start with SQLite, migrate to PostgreSQL for production).
- Clarify collaboration requirements (single workspace vs. multi-tenancy).
- Define retention policy for AI-generated data and logs.

